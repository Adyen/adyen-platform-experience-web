#!/usr/bin/env node

const fs = require('fs/promises');
const colors = require('ansi-colors');
const path = require('path');
const { program } = require('commander');
const { isTrue } = require('../core/utils');
const { EMPTY_OBJ, NOOP, TRANSLATIONS_CSV_PATH, TRANSLATIONS_JSON_PATH } = require('../constants');

colors.alias('error', colors.bold.italic.redBright);
colors.alias('success', colors.bold.italic.bgGreen);

program
    .name('translations')
    .description('Translations generation tools')
    .usage('<generate|help|unpack> [options] [arguments...]')
    .configureHelp({ sortSubcommands: true })
    .showHelpAfterError();

program.command('generate')
    .description('generate translations source file')
    .option('-h, --header', 'include header line')
    .option('-m, --manifest', 'output manifest data to specified output file or the default translations JSON file')
    .option('-o, --output [filepath]', 'output translations data to specified output file or the default translations source CSV file')
    .option('-s, --silent', 'use without the --output option to prevent writing output to \'stdout\'')
    .option('--smartling', 'include Smartling instructions (also includes header line)')
    .action(async ({ manifest, output, ...restOptions }) => {
        let outputFilePath = isTrue(output)
            ? isTrue(manifest) ? TRANSLATIONS_JSON_PATH : TRANSLATIONS_CSV_PATH
            : output;

        try {
            const options = {
                ...restOptions,
                output: (outputFilePath &&= path.resolve(outputFilePath))
            };

            await (isTrue(manifest)
                ? require('../core/manifest').export(options)
                : require('../core/csv').export(options));

            if (outputFilePath) {
                console.log(colors.success('[Translations data written to file]'));
                console.log(`${colors.greenBright('✓✓')} file://${outputFilePath}`);
            } else if (isTrue(restOptions.silent)) {
                console.log(colors.success('[Translations data generated]'));
            }
        } catch (reason) {
            isTrue(output) && await fs.rm(outputFilePath).catch(NOOP);
            console.error(colors.error(reason));
            throw reason;
        }
    });

program.command('unpack')
    .description('unpack translations source file')
    .argument('[source_file]', 'translations source file to be unpacked\r\n(when omitted, translations source will be read from \'stdin\')')
    .option('-m, --manifest [filepath]', 'reference manifest file for unpacking the translations\r\n(when omitted, default translations JSON file will be used if available)')
    .action(async (sourceFilePath, { manifest }) => {
        try {
            const resolvedManifest = (isTrue(manifest) ? EMPTY_OBJ : manifest) ?? EMPTY_OBJ;
            const manifestFilePath = path.resolve(resolvedManifest === EMPTY_OBJ ? TRANSLATIONS_JSON_PATH : resolvedManifest);

            const files = await require('../core/csv').unpack({
                deleteManifestFileAfterIfNotExisted: resolvedManifest === EMPTY_OBJ,
                manifest: manifestFilePath,
                source: sourceFilePath
            });

            console.log(colors.success(`[Translations source file unpacked]`));

            Object.keys(files).forEach(filepath => {
                console.log(`${files[filepath] ? colors.greenBright('✓✓') : colors.redBright('--')} file://${filepath}`);
            });
        } catch (reason) {
            console.error(colors.error(reason));
            throw reason;
        }
    });

program.parseAsync().catch(NOOP);
