#!/usr/bin/env node

const colors = require('ansi-colors');
const path = require('path');
const { program } = require('commander');
const { isTrue } = require('../core/utils');
const { EMPTY_OBJ, NOOP, TRANSLATIONS_CSV_PATH, TRANSLATIONS_JSON_PATH } = require('../constants');

colors.alias('error', colors.bold.italic.redBright);
colors.alias('success', colors.bold.italic.bgGreen);

program
    .name('translations')
    .description('Translations generation tools')
    .usage('<generate|help|unpack> [options] [arguments...]')
    .configureHelp({ sortSubcommands: true })
    .showHelpAfterError();

program.command('generate')
    .description('generate translations source file')
    .option('-h, --header', 'use without the --manifest option to include header line')
    .option('-m, --manifest', 'output manifest data to specified output file or the default translations JSON file')
    .option('-o, --out', 'write generated translations data to \'stdout\' (omit to write data to the output file)')
    .option('-s, --silent', 'use with the --out option to prevent writing output to \'stdout\'')
    .option('--smartling', 'use without the --manifest option to include Smartling instructions (also includes header line)')
    .action(async ({ manifest, out, silent, ...restOptions }) => {
        const generateManifest = isTrue(manifest);
        const writeToStdout = isTrue(out);

        try {
            const options = {
                ...restOptions,
                silent: writeToStdout && isTrue(silent),
                output: !writeToStdout && path.resolve(generateManifest ? TRANSLATIONS_JSON_PATH : TRANSLATIONS_CSV_PATH),
            };

            await (generateManifest
                ? require('../core/manifest').export(options)
                : require('../core/csv').export(options));

            if (options.output) {
                console.log(colors.success('[Translations data written to file]'));
                console.log(`${colors.greenBright('✓✓')} file://${options.output}`);
            } else if (options.silent) {
                console.log(colors.success('[Translations data generated]'));
            }
        } catch (reason) {
            console.error(colors.error(reason));
            throw reason;
        }
    });

program.command('unpack')
    .description('unpack translations source file')
    .argument('[source_file]', 'translations source file to be unpacked\r\n(when omitted, translations source will be read from \'stdin\')')
    .option('-m, --manifest [filepath]', 'reference manifest file for unpacking the translations\r\n(when omitted, default translations JSON file will be used if available)')
    .action(async (sourceFilePath, { manifest }) => {
        try {
            const resolvedManifest = (isTrue(manifest) ? EMPTY_OBJ : manifest) ?? EMPTY_OBJ;
            const manifestFilePath = path.resolve(resolvedManifest === EMPTY_OBJ ? TRANSLATIONS_JSON_PATH : resolvedManifest);

            const files = await require('../core/csv').unpack({
                deleteManifestFileAfterIfNotExisted: resolvedManifest === EMPTY_OBJ,
                manifest: manifestFilePath,
                source: sourceFilePath
            });

            console.log(colors.success(`[Translations source file unpacked]`));

            Object.keys(files).forEach(filepath => {
                console.log(`${files[filepath] ? colors.greenBright('✓✓') : colors.redBright('--')} file://${filepath}`);
            });
        } catch (reason) {
            console.error(colors.error(reason));
            throw reason;
        }
    });

program.parseAsync().catch(NOOP);
