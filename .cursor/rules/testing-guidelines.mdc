---
description: Unit test guidelines
globs: src/**/*.test.{ts
alwaysApply: false
---

# Unit testing guidelines

## Core Principles

<Warning>
**Critical Rule**: All test assertions must use concrete, deterministic values. No generic type checks or regex patterns allowed.
</Warning>

### 1. Deterministic Assertions Only

<DoNot>
```typescript
expect(typeof result).toBe('string')
expect(result.length).toBeGreaterThan(0)
expect(result).toMatch(/pattern/)
```
</DoNot>

<Do>
```typescript
expect(result).toBe('04:10 PM')
expect(result).toEqual(['04:10 PM', ''])
expect(getTime('UTC')).toEqual(['04:10 PM', ''])
```
</Do>

### 2. Data-Driven Testing

<Tip>
Extract reusable test data as constants before tests and use parameterized testing patterns. Prefer `forEach` loops over `test.each()` for better readability and debugging.
</Tip>

<Do>
```typescript
const TIMEZONE_DATA = [
  { 
    timezone: 'America/New_York',
    winter: { date: '12/25/2023', fullDate: 'Dec 25, 2023, 11:10:45' },
    summer: { date: '07/08/2023', fullDate: 'Jul 08, 2023, 12:10:45' }
  },
  { 
    timezone: 'Europe/London',
    winter: { date: '12/25/2023', fullDate: 'Dec 25, 2023, 16:10:45' },
    summer: { date: '07/08/2023', fullDate: 'Jul 08, 2023, 17:10:45' }
  }
];

test('should format dates correctly across DST and non-DST timezones', () => {
  TIMEZONE_DATA.forEach(({ timezone, winter, summer }) => {
    const { result } = renderHook(() => useTimezoneAwareDateFormatting(timezone));
    const { dateFormat, fullDateFormat } = result.current;

    expect(dateFormat(WINTER_TIMESTAMP)).toBe(winter.date);
    expect(fullDateFormat(WINTER_TIMESTAMP)).toBe(winter.fullDate);
    expect(dateFormat(SUMMER_TIMESTAMP)).toBe(summer.date);
    expect(fullDateFormat(SUMMER_TIMESTAMP)).toBe(summer.fullDate);
  });
});
```
</Do>

### 3. Real Implementation Over Mocking

<Do>
- Use real implementations with controlled inputs
- Control behavior through `vi.useFakeTimers()` and `vi.setSystemTime()`
- Only mock external dependencies, not internal utilities
- Use `spy: true` option when spying is needed
</Do>

<DoNot>
- Mock core utilities unnecessarily
- Mock what can be controlled through inputs
- Create fake implementations when real ones can be controlled
</DoNot>

## File Structure & Setup

### Import Organization

<Do>
```typescript
// System imports (alphabetical)
import { afterEach, beforeEach, describe, expect, test, vi } from 'vitest';
import { renderHook } from '@testing-library/preact';

// Local imports
import useHook, { helperFunction } from './useHook';
import Localization from '../core/Localization/Localization';

vi.mock('../core/Context/useCoreContext');
```
</Do>

### Constants & Test Data

<Do>
```typescript
// Move constants inside describe blocks for better organization
describe('useHook', () => {
  const mockUseCoreContext = vi.mocked(useCoreContext);
  
  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(1703520645123); // Dec 25, 2023, 4:10:45.123 PM UTC
    mockUseCoreContext.mockReturnValue({ i18n: new Localization().i18n } as any);
  });
  
  // Move test-specific constants close to their usage
  test('should handle timezone formatting', () => {
    const WINTER_TIMESTAMP = 1703520645123; // Dec 25, 2023
    const SUMMER_TIMESTAMP = 1688832645123; // July 8, 2023
    // ... test logic
  });
});
```
</Do>

### Global Setup Pattern

<Template>
```typescript
describe('ModuleName', () => {
  beforeEach(() => {
    vi.useFakeTimers();
    vi.setSystemTime(SYSTEM_TIMESTAMP);
    // Other common setup
  });

  afterEach(() => {
    vi.useRealTimers();
    vi.restoreAllMocks();
  });
});
```
</Template>

## Test Design Patterns

### Test Organization

<Checklist>
- [ ] Keep test structure flat - avoid nested `describe` blocks unless absolutely necessary
- [ ] Use meaningful test names: `'should return correct time and offset for valid IANA timezones'`
- [ ] Include these test categories: primary use case, edge cases, invalid inputs, consistency
- [ ] Group related test scenarios in single tests using data-driven patterns
- [ ] Merge tests that validate the same underlying behavior (e.g., nullish parameter handling)
</Checklist>

### Variable Organization & Naming

<Do>
```typescript
test('should handle nullish timezones gracefully', () => {
  const currentTime = Date.now();
  const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const formatOptions = { month: 'short', day: 'numeric', year: 'numeric', timeZoneName: 'short' } as const;
  const systemTimezoneFormat = new Intl.DateTimeFormat('en-US', { ...formatOptions, timeZone: systemTimezone }).format(currentTime);

  // All nullish timezones should fall back to system timezone
  const { result: noParamResult } = renderHook(() => useTimezoneAwareDateFormatting());
  const { result: nullResult } = renderHook(() => useTimezoneAwareDateFormatting(null as any));
  const { result: undefinedResult } = renderHook(() => useTimezoneAwareDateFormatting(undefined));

  expect(noParamResult.current.dateFormat(currentTime, formatOptions)).toBe(systemTimezoneFormat);
  expect(nullResult.current.dateFormat(currentTime, formatOptions)).toBe(systemTimezoneFormat);
  expect(undefinedResult.current.dateFormat(currentTime, formatOptions)).toBe(systemTimezoneFormat);
});
```
</Do>

<DoNot>
```typescript
// ❌ AVOID: Over-complicated variable organization
const commonOptions = { month: 'short', day: 'numeric', year: 'numeric' } as const;
const expectedBasicFormat = new Intl.DateTimeFormat('en-US', { timeZone: systemTimezone }).format(currentTime);
const expectedWithTimezone = new Intl.DateTimeFormat('en-US', { 
  ...commonOptions, 
  timeZoneName: 'short', 
  timeZone: systemTimezone 
}).format(currentTime);

// Testing multiple scenarios with different expectations
expect(nullResult.result.current.dateFormat(currentTime)).toBe(expectedBasicFormat);
const formattedDate = noParamResult.result.current.dateFormat(currentTime, {...});
expect(formattedDate).toBe(expectedWithTimezone);
```
</DoNot>

### Object-Level Assertions

<Do>
```typescript
// PREFER: Object equality
expect(result.current).toEqual({
  timezone: 'UTC',
  clockTime: '04:10 PM', 
  GMTOffset: '',
  timestamp: SYSTEM_TIMESTAMP
});
```
</Do>

<DoNot>
```typescript
// AVOID: Individual property checks
expect(result.current.timezone).toBe('UTC');
expect(result.current.clockTime).toBe('04:10 PM');
expect(result.current.GMTOffset).toBe('');
```
</DoNot>

### Hook Testing Pattern

<Template>
```typescript
test('should return stable function references when timezone does not change', () => {
  const { result, rerender } = renderHook(() => useTimezoneAwareDateFormatting('America/New_York'));
  const initialResult = result.current;
  const { dateFormat, fullDateFormat } = result.current;

  rerender();
  expect(result.current).toStrictEqual(initialResult);
  expect(result.current.dateFormat).toBe(dateFormat); // Function reference stability
  expect(result.current.fullDateFormat).toBe(fullDateFormat);
});

test('should return new function references when timezone changes', () => {
  const { result, rerender } = renderHook(useTimezoneAwareDateFormatting, { initialProps: 'America/New_York' });
  const initialResult = result.current;
  const { dateFormat, fullDateFormat } = result.current;

  rerender('Europe/London');
  expect(result.current).not.toStrictEqual(initialResult);
  expect(result.current.dateFormat).not.toBe(dateFormat); // New function reference
  expect(result.current.fullDateFormat).not.toBe(fullDateFormat);
});
```
</Template>

### Code Style & Formatting

<Do>
```typescript
// ✅ Consistent formatting and trailing commas
const DATE_FORMATS = [
  {
    options: { year: 'numeric', month: 'short', day: 'numeric', timeZoneName: 'short' } as const,
    expectations: {
      'America/New_York': 'Dec 25, 2023, EST',
      'Europe/London': 'Dec 25, 2023, GMT',
      'Asia/Tokyo': 'Dec 26, 2023, GMT+9',
    },
  },
  {
    options: {
      month: 'numeric',
      day: 'numeric', 
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      timeZoneName: 'shortGeneric',
    } as const,
    expectations: {
      'America/New_York': '12/25/2023, 11:10 AM ET',
      'Europe/London': '12/25/2023, 4:10 PM United Kingdom Time',
    },
  },
];

// ✅ Simple arrays stay inline, complex ones get expanded
[Date.now(), new Date(), new Date().toISOString()].forEach(date => {
  expect(dateFormat(date)).toBe('12/26/2023');
});
```
</Do>

<DoNot>
```typescript
// ❌ AVOID: Inconsistent formatting
const DATE_FORMATS = [
  {
    options: { year: 'numeric', month: 'short', day: 'numeric', timeZoneName: 'short' } as const,
    expectations: {
      'America/New_York': 'Dec 25, 2023, EST',
      'Europe/London': 'Dec 25, 2023, GMT'  // Missing trailing comma
    }
  }
];

// ❌ AVOID: Unnecessary multi-line for simple arrays
[
  Date.now(), // number
  new Date(), // Date object  
  new Date().toISOString(), // string
].forEach(date => {
  expect(dateFormat(date)).toBe('12/26/2023');
});
```
</DoNot>

## Technical Standards

### Coverage Requirements

<Important>
**Minimum Requirements:**
- 85% statement/line coverage
- Test all exported functions  
- Include edge cases, error conditions
- DST scenarios for date/time code
</Important>

### Async Handling

<Do>
```typescript
test('should handle time advancement', async () => {
  await vi.advanceTimersByTimeAsync(5000);
  expect(result.current.timestamp).not.toBe(initialTimestamp);
});
```
</Do>

### Error Testing

<Template>
```typescript
// ✅ Test error conditions with concrete expectations
test('should handle invalid date inputs gracefully', () => {
  const { result } = renderHook(() => useTimezoneAwareDateFormatting());
  const { dateFormat, fullDateFormat } = result.current;

  [new Date('unknown'), new Date('unknown').getTime()].forEach(invalidDate => {
    expect(dateFormat(invalidDate)).toBe('Invalid Date');
    expect(fullDateFormat(invalidDate)).toBe('Invalid Date');
  });
});
```
</Template>

### System-Dependent Testing

<Do>
```typescript
// ✅ Calculate expected values from system behavior
test('should handle nullish timezones gracefully', () => {
  const currentTime = Date.now();
  const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
  const formatOptions = { month: 'short', day: 'numeric', year: 'numeric', timeZoneName: 'short' } as const;
  const systemTimezoneFormat = new Intl.DateTimeFormat('en-US', { 
    ...formatOptions, 
    timeZone: systemTimezone 
  }).format(currentTime);

  const { result } = renderHook(() => useTimezoneAwareDateFormatting());
  expect(result.current.dateFormat(currentTime, formatOptions)).toBe(systemTimezoneFormat);
});
```
</Do>

<DoNot>
```typescript
// ❌ AVOID: Generic assertions for system-dependent behavior
expect(formattedDate).toMatch(/^[A-Z][a-z]{2} \d{1,2}, \d{4}, GMT[+-]?\d*$/);
expect(formattedDate).toContain('Dec 25, 2023');
expect(typeof result).toBe('string');
```
</DoNot>

## Anti-Patterns to Avoid

### Forbidden Assertions

<DoNot>
```typescript
// ❌ NEVER use these patterns
expect(typeof result).toBe('string')
expect(result.length).toBeGreaterThan(0)
expect(result).toMatch(/pattern/)
```
</DoNot>

<Do>
```typescript
// ✅ ALWAYS use concrete values
expect(result).toBe('specific-expected-value')
expect(result).toEqual(['exact', 'array'])
```
</Do>

### Over-Mocking

<Warning>
**Avoid These Practices:**
- Mocking core utilities unnecessarily
- Mocking what can be controlled through inputs
- Creating fake implementations when real ones work
- Prefer real `Intl.DateTimeFormat` over mocked implementations
</Warning>

### Test Repetition & Consolidation

<Tip>
Don't create multiple tests that test the same logic with different inputs. Consolidate into parameterized tests using data arrays. Merge tests that validate the same underlying behavior.
</Tip>

<Do>
```typescript
// ✅ GOOD: Single test with data-driven approach
test('should format dates correctly across DST and non-DST timezones', () => {
  const TIMEZONE_DATA = [
    { timezone: 'America/New_York', winter: { date: '12/25/2023' }, summer: { date: '07/08/2023' }},
    { timezone: 'Europe/London', winter: { date: '12/25/2023' }, summer: { date: '07/08/2023' }}
  ];
  
  TIMEZONE_DATA.forEach(({ timezone, winter, summer }) => {
    const { result } = renderHook(() => useTimezoneAwareDateFormatting(timezone));
    expect(result.current.dateFormat(WINTER_TIMESTAMP)).toBe(winter.date);
    expect(result.current.dateFormat(SUMMER_TIMESTAMP)).toBe(summer.date);
  });
});

// ✅ GOOD: Merged nullish parameter handling
test('should handle nullish timezones gracefully', () => {
  // Tests null, undefined, and omitted parameters in one place
  const { result: nullResult } = renderHook(() => useTimezoneAwareDateFormatting(null as any));
  const { result: undefinedResult } = renderHook(() => useTimezoneAwareDateFormatting(undefined));
  const { result: noParamResult } = renderHook(() => useTimezoneAwareDateFormatting());
  
  // All should behave identically
  expect(nullResult.current.dateFormat(currentTime, formatOptions)).toBe(expectedFormat);
  expect(undefinedResult.current.dateFormat(currentTime, formatOptions)).toBe(expectedFormat);
  expect(noParamResult.current.dateFormat(currentTime, formatOptions)).toBe(expectedFormat);
});
```
</Do>

<DoNot>
```typescript
// ❌ AVOID: Multiple tests for the same behavior
test('should work with no timezone parameter', () => { /* ... */ });
test('should handle null timezone', () => { /* ... */ });
test('should handle undefined timezone', () => { /* ... */ });

// ❌ AVOID: Separate tests for each timezone
test('should format America/New_York correctly', () => { /* ... */ });
test('should format Europe/London correctly', () => { /* ... */ });
test('should format Asia/Tokyo correctly', () => { /* ... */ });
```
</DoNot>

## File Conventions

### Naming & Location

<Info>
**File Structure:**
- Test files: `{filename}.test.ts` or `{filename}.test.tsx`
- Place test files adjacent to source files
- Use `@vitest-environment jsdom` for React hooks and components
</Info>

### Framework Usage

<Important>
**Tech Stack:**
- Vitest + @testing-library/preact for React hooks
- Use `renderHook` for hook testing
- Use `vi.useFakeTimers()` for time-dependent code
</Important>

## Quality Checklist

<Checklist>
Before completing any test file, verify:

- [ ] All assertions use concrete, predictable values (no `typeof`, `toMatch`, `toContain`)
- [ ] No generic assertions or regex patterns for deterministic behavior
- [ ] Reusable test data extracted to constants and moved close to usage
- [ ] Common setup moved to `beforeEach`, test-specific constants in test functions
- [ ] Tests are independent and can run in any order
- [ ] Edge cases and error conditions covered with concrete expectations
- [ ] Async operations use proper async/await patterns
- [ ] Coverage meets 85% minimum requirement
- [ ] Test structure is flat (avoid nested `describe` blocks)
- [ ] Related test scenarios merged into single data-driven tests
- [ ] Variable names are descriptive and purpose-driven
- [ ] Code style is consistent (trailing commas, formatting, spacing)
- [ ] System-dependent behavior tested with calculated expected values
- [ ] Function reference stability tested where applicable
</Checklist>

## Success Criteria

<Important>
**Tests Must:**
- Be deterministic and repeatable (no flaky tests)
- Serve as living documentation of expected behavior
- Clearly indicate problems when they fail with concrete value mismatches
- Use real implementations wherever possible
- Follow data-driven patterns to reduce duplication
- Maintain clean, consistent code style and organization
- Test system-dependent behavior with calculated expectations
- Consolidate related scenarios to avoid test repetition
</Important>
